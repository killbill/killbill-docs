When an end-user is charged against a payment method, this is encapsulated as a *payment* in Kill Bill. These details need to be recorded in Kill Bill.


=== Payment flows overview

*Payment flows* describe the flows that occur when a merchant site invokes the Kill Bill payment APIs for charging a customer. Thus,
these flows are not applicable for recurring payments initiated by Kill Bill.

Kill Bill supports two main payment flows, referred to as *Hosted Payment Pages* (or *HPP*) and as *Gateway integration*:

* A *HPP* flow is when the payment is completely outsourced, either by redirecting the user to a third-party website or by hosting a form or an iframe, that submits the information to a third-party website
* A *Gateway integration* flow is when the customer doesn't leave your website and Kill Bill processes the payment directly by calling a gateway API

For a concrete example on how the two flows can be implemented, take a look at our https://github.com/killbill/killbill-adyen-demo[Adyen demo].

In the flow diagrams below, we consider the following actors:

* *Browser*: user sitting behind a browser and initiating the payment flow
* *Merchants Site*: customer facing web site which receives the order and shields the payment system (i.e. Kill Bill)
* *Payments*: the payment system (i.e. Kill Bill and its specific payment plugins which interact with the payment providers) offering APIs for the various flows
* *Payment Provider*: also called Payment Service Provider (PSP), Payment Gateway or simply Gateway, this is the entity that will process the payment
* *Access Control Server* (optional): in the case of 3D-Secure checkout, the user is redirected to some third party entity to enter custom information that will validate whether he can pursue with the payment flow

=== Hosted Payment Page flow

During an HPP flow, the customer enters his payment method information (either on the main Merchants Site or a third-party site) and then submits a form containing that information to make the payment. To obtain the information required to present the user with a payment form (specific form fields or URL where the form is hosted), call the https://github.com/killbill/killbill-api/blob/master/src/main/java/org/killbill/billing/payment/api/PaymentGatewayApi.java[*buildFormDescriptor*] API.

The result of the API call will depend on the type of HPP integration:

* If the payment form is hosted on your own website (but the form data will be sent to a third-party website), the response will list the exact fields to set, such as required visible fields (the names will vary depending on the gateway, for instance some expect a `Sum` field instead of `amount`) and required hidden fields (e.g. `merchantId` value). For https://developer.paypal.com/docs/classic/paypal-payments-standard/ht_test-pps-buttons/[PayPal Payments Standard Buttons] for example, the API would return the values of the fields *cmd*, *hosted_button_id* and *submit*. The browser submits the payment information to the payment provider, which then redirects the customer to a landing page upon success or failure.
* If the payment form is completely hosted on a third-party website, the response will contain a URL to redirect the user to. This URL can be generic or unique (generated by the payment plugin either by submitting the order information to the gateway or by constructing the special URL via query parameters). For https://docs.adyen.com/classic-integration/hosted-payment-pages/hosted-payment-pages-api[Adyen HPPs] for example, the API would return a url like https://live.adyen.com/hpp/select.shtml. The browser is redirected to the payment provider website for the customer to complete the payment before being redirected back to a landing page upon success or failure.

Note that after calling *buildFormDescriptor*, the payment may or may not exist in Kill Bill: this will depend on the plugin. If it does however, it will be most likely in a **PENDING** state.

Here are a few common scenarios:

* the HPP provider doesn't provide an API to retrieve the state of the payment, nor sends notifications: the only way to record the payment is when the user is redirected to the Merchants Site. In that case, *buildFormDescriptor* can simply return the data to create the form and/or redirect the user without creating any payment. When the user completes the payment and is redirected back to the site, the Merchants Site will need to record the payment explicitly by calling the *createPurchase* API. Alternatively, if you want to keep track of abandoned purchases, the plugin could create a payment in a *PENDING* state during the *buildFormDescriptor* call. After the redirect, the Merchants Site will still call the *createPurchase* API to complete the payment, but will pass the paymentId returned by the previous *buildFormDescriptor* call.

.Payment created during the redirect

image::../assets/img/payment-userguide/hpp_purchase_on_redirect.svg[align="center"]

.Pending payment created during the *buildFormDescriptor* call, completed during the redirect

image::../assets/img/payment-userguide/hpp_purchase_on_redirect_with_pending_payment.svg[align="center"]

* the HPP provider provides an API to retrieve the state of the payment but does not send notifications. In this case, the URL constructed during the *buildFormDescriptor* call is most likely unique, and contains enough information for the plugin to poll the provider for the payment status. During the  *buildFormDescriptor* call, the plugin will need to create a *PENDING* payment. Kill Bill will automatically poll the plugin calling the *getPaymentInfo* API, which should query the provider for the latest payment status. Example: Boleto with PayU Latam.

.Pending payment created during the *buildFormDescriptor* call, completed by polling *getPaymentInfo*

image::../assets/img/payment-userguide/hpp_poll.svg[align="center"]

* the HPP provider doesn't provide an API to retrieve the state of the payment but does send notifications. In this case, *buildFormDescriptor* can simply return the redirect URL without creating a payment, which will be created when the notification is received. Similarly to the first case above, you could create a *PENDING* payment if you want to track abandoned purchases, just make sure that the plugin has enough metadata to reconcile the notification with the payment. When the notification is received, either use the *notifyPendingTransactionOfStateChanged* Kill Bill API to transition the payment, or wait for Kill Bill to poll the plugin via  the *getPaymentInfo* API. Example: any HPP provided by Adyen.

.Payment created when receiving a notification from the provider

image::../assets/img/payment-userguide/hpp_notifications.svg[align="center"]

.Pending payment created during the *buildFormDescriptor* call, completed when receiving a notification from the provider

image::../assets/img/payment-userguide/hpp_notifications_with_pending_payment.svg[align="center"]

The conceptual flow below shows a 3D-Secure variation of the previous flows. The main difference is that prior redirecting the browser to the landing page, it is first redirected to the access control server where the user can enter custom information.

.Hosted Payment Page 3D-Secure variation

image::../assets/img/payment-userguide/payments_hostedpages_3ds.svg[align="center"]

=== Gateway Integration Flow

For gateway integrations, the entry point for any payment is either the https://github.com/killbill/killbill-api/blob/master/src/main/java/org/killbill/billing/payment/api/PaymentApi.java[*createAuthorization*] (to authorize a credit card), https://github.com/killbill/killbill-api/blob/master/src/main/java/org/killbill/billing/payment/api/PaymentApi.java[*createPurchase*] (to charge a payment method, for example authorizing and capturing a credit card, to initiate an ACH transfer, to withdraw money from a Bitcoin wallet, etc.) or https://github.com/killbill/killbill-api/blob/master/src/main/java/org/killbill/billing/payment/api/PaymentApi.java[*createCredit*] (to deposit money on a payment method, without any reference to a previous payment) APIs. The payment state will be in `*_INIT` state before calling the plugin.

There are two main types of scenarios:

* When payment gateways provide synchronous APIs, transactions end up in a terminal state right away. The following figure demonstrates this scenario:
+
.Gateway integration (With Synchronous Payment API)

image::../assets/img/payment-userguide/payments_gateway.svg[align="center"]
+
The payment is initiated using one of the *createAuthorization* or *createPurchase* APIs. Kill Bill then connects to its payment plugin, which in turn contacts the gateway to perform the required operation. Upon success/failure, the end-user is redirected to a landing page.
+
[NOTE]
*Note:* Before any payment operation can occur, the user must first enter his/her payment information and a payment method must be created as explained in the <<payment_method_flows, payment method flows>> section. This is not represented in the flow above; it can happen either in a prior step or during the payment using one of our https://killbill.github.io/slate/#payment-combo-api-to-create-a-new-payment-transaction-on-a-existing-or-not-account[combo payment call].
+
* In some cases, a plugin can choose to set the status to *PENDING*. For example, this is the case for 3D-Secure transactions (until the issuer verifies the payment after redirecting the user), for direct debit transfers (e.g., ACH, which usually takes a couple of days for banks to acknowledge), or for Bitcoin transfers (until blockchain confirms the transaction). Additionally, some gateways don't always provide synchronous responses (e.g., when using Adyen to capture funds), in which case the plugin has to rely on asynchronous notifications to transition the payment into a terminal state. The <<Janitor, Kill Bill Janitor>> can also be used to automatically fix *PENDING* states.
+
The following figure demonstrates the Janitor scenario:
+
.Gateway integration (With Asynchronous payment)
image::../assets/img/payment-userguide/janitor.svg[width=960,align="center"]
